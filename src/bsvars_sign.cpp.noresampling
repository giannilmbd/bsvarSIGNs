
#include <RcppArmadillo.h>
#include "progress.hpp"
#include "Rcpp/Rmath.h"
#include <bsvars.h>
// #include <omp.h>

#include "sample_hyper.h"
#include "sample_Q.h"
#include "sample_NIW.h"

using namespace Rcpp;
using namespace arma;


// [[Rcpp::interfaces(cpp)]]
// [[Rcpp::export]]
Rcpp::List bsvar_sign_cpp(
    const int&        S,                  // number of draws from the posterior
    const int&        p,                  // number of lags
    const arma::mat&  Y,                  // TxN dependent variables
    const arma::mat&  X,                  // TxK dependent variables
    const arma::cube& sign_irf,           // NxNxh cube of signs for impulse response function
    const arma::mat&  sign_narrative,     // ANYx6 matrix of signs for historical decomposition
    const arma::mat&  sign_B,             // NxN matrix of signs for B
    const arma::field<arma::mat>& Z,      // a list of zero restrictions
    const Rcpp::List& prior,              // a list of priors
    const bool        show_progress = true,
    const int         thin = 100,         // introduce thinning
    const int&        max_tries = 10000,   // maximum tries for Q draw
    const int&        n_draws = 10        // number of Q draws per posterior sample
  ) {
  
  std::string oo = "";
  if ( thin != 1 ) {
    oo      = bsvars::ordinal(thin) + " ";
  }
  
  // Progress bar setup
  double num_threads = 1;
  // #pragma omp parallel
  // {
  //   num_threads = omp_get_num_threads();
  // }
  vec prog_rep_points = arma::round(arma::linspace(0, S / num_threads, 50));
  if (show_progress) {
    Rcout << "**************************************************|" << endl;
    Rcout << " bsvarSIGNs: Bayesian Structural VAR with sign,   |" << endl;
    Rcout << "             zero and narrative restrictions      |" << endl;
    Rcout << "**************************************************|" << endl;
    // Rcout << " Gibbs sampler for the SVAR model                 |" << endl;
    // Rcout << "**************************************************|" << endl;
    Rcout << " Progress of simulation for " << S << " independent draws" << endl;
    // Rcout << "    Every " << oo << "draw is saved via MCMC thinning" << endl;
    Rcout << " Press Esc to interrupt the computations" << endl;
    Rcout << "**************************************************|" << endl;
  }
  Progress bar(50, show_progress);
  
  const int  T = Y.n_rows;
  const int  N = Y.n_cols;
  const int  K = X.n_cols;
  
  const int total_draws = S * n_draws; // Total number of draws
  vec        posterior_w(total_draws);
  mat        posterior_hyper(N + 3, total_draws);
  cube       posterior_A(N, K, total_draws);
  cube       posterior_B(N, N, total_draws);
  cube       posterior_Q(N, N, total_draws);
  cube       posterior_Sigma(N, N, total_draws);
  cube       posterior_Theta0(N, N, total_draws);
  cube       posterior_shocks(N, T, total_draws);
  
  mat        hypers = as<mat>(prior["hyper"]);
  
  int        S_hyper  = hypers.n_cols - 1;
  int        prior_nu = as<int>(prior["nu"]);
  int        post_nu  = prior_nu + T;
  int        n_tries;
  
  double     w, mu, delta, lambda;
  
  vec        hyper, psi;
  vec        prior_v = as<mat>(prior["V"]).diag();
  
  mat        B, Sigma, chol_Sigma, h_invp, Q, shocks;
  mat        prior_V, prior_S, post_B, post_V, post_S;
  mat        Ystar, Xstar, Yplus, Xplus;
  mat        prior_B = as<mat>(prior["B"]);
  mat        Ysoc    = as<mat>(prior["Ysoc"]);
  mat        Xsoc    = as<mat>(prior["Xsoc"]);
  mat        Ysur    = as<mat>(prior["Ysur"]);
  mat        Xsur    = as<mat>(prior["Xsur"]);
  
  field<mat> result;
  
 // Either parallelize the outer block or the inner loop; both can be done but is
//#pragma omp parallel for shared(posterior_w, posterior_A, posterior_B, posterior_Q, posterior_Sigma, posterior_Theta0, posterior_shocks, prog_rep_points, bar) \
//  private(hyper, mu, delta, lambda, psi, prior_V, prior_S, Ystar, Xstar, Yplus, Xplus, result, post_B, post_V, post_S, post_nu, Sigma, chol_Sigma, B, h_invp, Q, shocks)
int s = 0; // Initialize the counter for posterior draws

int total_valid_draws = 0; // Counter for total valid draws across all iterations

while (s < S) {
    // Sample hyperparameters
    hyper        = hypers.col(randi(distr_param(0, S_hyper)));
    mu           = hyper(0);
    delta        = hyper(1);
    lambda       = hyper(2);
    psi          = hyper.rows(3, N + 2);

    // Update Minnesota prior
    prior_V      = diagmat(prior_v % join_vert(lambda * lambda * repmat(1 / psi, p, 1),
                                               ones<vec>(K - N * p)));
    prior_S      = diagmat(psi);

    // Update dummy observation prior
    Ystar        = join_vert(Ysoc / mu, Ysur / delta);
    Xstar        = join_vert(Xsoc / mu, Xsur / delta);
    Yplus        = join_vert(Ystar, Y);
    Xplus        = join_vert(Xstar, X);

    // Posterior parameters
    result       = niw_cpp(Yplus, Xplus, prior_B, prior_V, prior_S, prior_nu);
    post_B       = result(0);
    post_V       = result(1);
    post_S       = result(2);
    post_nu      = as_scalar(result(3));

    // Sample reduced-form parameters (once per s iteration)
    Sigma      = iwishrnd(post_S, post_nu);
    chol_Sigma = chol(Sigma, "lower");
    B          = rmatnorm_cpp(post_B, post_V, Sigma);
    h_invp     = inv(trimatl(chol_Sigma)); // lower tri, h(Sigma) is upper tri

    // Initialize containers for Qs, shocks, and weights
    cube Q_all(N, N, n_draws);
    cube shocks_all(N, T, n_draws);
    vec weights(n_draws, fill::zeros);

    int valid_draws = 0; // Counter for valid draws in this iteration

    #pragma omp parallel shared(Q_all, shocks_all, weights, valid_draws, p, Y, X, prior, sign_irf, sign_narrative, sign_B, Z, max_tries) \
                         firstprivate(Sigma, chol_Sigma, B, h_invp)
    {
        int local_valid_draws = 0; // Thread-local counter
        #pragma omp for
        for (int i = 0; i < n_draws; i++) {
            int local_tries = 0;
            double local_w = 0;
            mat local_Q, local_shocks;

            while (local_w == 0 && (local_tries < max_tries || max_tries == 0)) {
                // Call sample_Q (draw Q for the same Sigma, chol_Sigma, B, and h_invp)
                field<mat> local_result = sample_Q(p, Y, X, B, h_invp, chol_Sigma, prior, 
                                                   sign_irf, sign_narrative, sign_B, Z, 1);
                local_Q      = local_result(0);
                local_shocks = local_result(1);
                local_w      = as_scalar(local_result(2));

                local_tries++;
            }

            // If the draw is valid, store the results
            if (local_w > 0) {
                Q_all.slice(local_valid_draws) = local_Q;
                shocks_all.slice(local_valid_draws) = local_shocks;
                weights(local_valid_draws) = local_w;
                local_valid_draws++;
            }
        }

        // Combine thread-local results into the shared counter
        #pragma omp critical
        {
            valid_draws += local_valid_draws;
        }
    }

    // If no valid draws were obtained, skip this iteration
    if (valid_draws == 0) {
        continue; // Skip to the next iteration without incrementing `s`
    }

    // Assemble results for each valid Q
    for (int i = 0; i < valid_draws; i++) {
        int index = total_valid_draws + i; // Use total_valid_draws for sequential indexing
        posterior_w(index)            = weights(i);
        posterior_A.slice(index)      = B.t(); // Same B for all Qs
        posterior_B.slice(index)      = Q_all.slice(i).t() * h_invp;
        posterior_Q.slice(index)      = Q_all.slice(i);
        posterior_Sigma.slice(index)  = Sigma; // Same Sigma for all Qs
        posterior_Theta0.slice(index) = chol_Sigma * Q_all.slice(i);
        posterior_shocks.slice(index) = shocks_all.slice(i);
    }

    // Increment the total number of valid draws
    total_valid_draws += valid_draws;

    // Increment progress bar
    if (any(prog_rep_points == s)) {
        #pragma omp critical
        bar.increment();
    }

    s++; // Increment the counter for posterior draws
}

// Trim the arrays to include only valid draws
posterior_w.resize(total_valid_draws);
posterior_A.resize(N, K, total_valid_draws);
posterior_B.resize(N, N, total_valid_draws);
posterior_Q.resize(N, N, total_valid_draws);
posterior_Sigma.resize(N, N, total_valid_draws);
posterior_Theta0.resize(N, N, total_valid_draws);
posterior_shocks.resize(N, T, total_valid_draws);

// Return the results
return List::create(
    _["posterior"]  = List::create(
      _["w"]        = posterior_w,
      _["hyper"]    = posterior_hyper,
      _["A"]        = posterior_A,
      _["B"]        = posterior_B,
      _["Q"]        = posterior_Q,
      _["Sigma"]    = posterior_Sigma,
      _["Theta0"]   = posterior_Theta0,
      _["shocks"]   = posterior_shocks
    )
);
} // END bsvar_sign_cpp

